import {
  BigNumber,
  getAddress,
  init_lib3 as init_lib,
  init_lib6 as init_lib2
} from "./chunk-62P73FLT.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-BYPFWIQ6.js";

// node_modules/@uniswap/sdk-core/node_modules/jsbi/dist/jsbi.mjs
var JSBI, jsbi_default;
var init_jsbi = __esm({
  "node_modules/@uniswap/sdk-core/node_modules/jsbi/dist/jsbi.mjs"() {
    JSBI = class _JSBI extends Array {
      constructor(i, _) {
        if (super(i), this.sign = _, i > _JSBI.__kMaxLength)
          throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i) {
        var _ = Math.floor, t = Number.isFinite;
        if ("number" == typeof i) {
          if (0 === i)
            return _JSBI.__zero();
          if (_JSBI.__isOneDigitInt(i))
            return 0 > i ? _JSBI.__oneDigit(-i, true) : _JSBI.__oneDigit(i, false);
          if (!t(i) || _(i) !== i)
            throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
          return _JSBI.__fromDouble(i);
        }
        if ("string" == typeof i) {
          const _2 = _JSBI.__fromString(i);
          if (null === _2)
            throw new SyntaxError("Cannot convert " + i + " to a BigInt");
          return _2;
        }
        if ("boolean" == typeof i)
          return true === i ? _JSBI.__oneDigit(1, false) : _JSBI.__zero();
        if ("object" == typeof i) {
          if (i.constructor === _JSBI)
            return i;
          const _2 = _JSBI.__toPrimitive(i);
          return _JSBI.BigInt(_2);
        }
        throw new TypeError("Cannot convert " + i + " to a BigInt");
      }
      toDebugString() {
        const i = ["BigInt["];
        for (const _ of this)
          i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
        return i.push("]"), i.join("");
      }
      toString(i = 10) {
        if (2 > i || 36 < i)
          throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i & i - 1) ? _JSBI.__toStringBasePowerOfTwo(this, i) : _JSBI.__toStringGeneric(this, i, false);
      }
      static toNumber(i) {
        const _ = i.length;
        if (0 === _)
          return 0;
        if (1 === _) {
          const _2 = i.__unsignedDigit(0);
          return i.sign ? -_2 : _2;
        }
        const t = i.__digit(_ - 1), e = _JSBI.__clz30(t), n = 30 * _ - e;
        if (1024 < n)
          return i.sign ? -Infinity : 1 / 0;
        let g = n - 1, o = t, s = _ - 1;
        const l = e + 3;
        let r = 32 === l ? 0 : o << l;
        r >>>= 12;
        const a = l - 12;
        let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
        for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; )
          s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
        const h = _JSBI.__decideRounding(i, d, s, o);
        if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g))))
          return i.sign ? -Infinity : 1 / 0;
        const m = i.sign ? -2147483648 : 0;
        return g = g + 1023 << 20, _JSBI.__kBitConversionInts[1] = m | g | r, _JSBI.__kBitConversionInts[0] = u, _JSBI.__kBitConversionDouble[0];
      }
      static unaryMinus(i) {
        if (0 === i.length)
          return i;
        const _ = i.__copy();
        return _.sign = !i.sign, _;
      }
      static bitwiseNot(i) {
        return i.sign ? _JSBI.__absoluteSubOne(i).__trim() : _JSBI.__absoluteAddOne(i, true);
      }
      static exponentiate(i, _) {
        if (_.sign)
          throw new RangeError("Exponent must be positive");
        if (0 === _.length)
          return _JSBI.__oneDigit(1, false);
        if (0 === i.length)
          return i;
        if (1 === i.length && 1 === i.__digit(0))
          return i.sign && 0 == (1 & _.__digit(0)) ? _JSBI.unaryMinus(i) : i;
        if (1 < _.length)
          throw new RangeError("BigInt too big");
        let t = _.__unsignedDigit(0);
        if (1 === t)
          return i;
        if (t >= _JSBI.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        if (1 === i.length && 2 === i.__digit(0)) {
          const _2 = 1 + (0 | t / 30), e2 = i.sign && 0 != (1 & t), n2 = new _JSBI(_2, e2);
          n2.__initializeDigits();
          const g = 1 << t % 30;
          return n2.__setDigit(_2 - 1, g), n2;
        }
        let e = null, n = i;
        for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1)
          n = _JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = _JSBI.multiply(e, n));
        return e;
      }
      static multiply(_, t) {
        if (0 === _.length)
          return _;
        if (0 === t.length)
          return t;
        let i = _.length + t.length;
        30 <= _.__clzmsd() + t.__clzmsd() && i--;
        const e = new _JSBI(i, _.sign !== t.sign);
        e.__initializeDigits();
        for (let n = 0; n < _.length; n++)
          _JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
        return e.__trim();
      }
      static divide(i, _) {
        if (0 === _.length)
          throw new RangeError("Division by zero");
        if (0 > _JSBI.__absoluteCompare(i, _))
          return _JSBI.__zero();
        const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
        let n;
        if (1 === _.length && 32767 >= e) {
          if (1 === e)
            return t === i.sign ? i : _JSBI.unaryMinus(i);
          n = _JSBI.__absoluteDivSmall(i, e, null);
        } else
          n = _JSBI.__absoluteDivLarge(i, _, true, false);
        return n.sign = t, n.__trim();
      }
      static remainder(i, _) {
        if (0 === _.length)
          throw new RangeError("Division by zero");
        if (0 > _JSBI.__absoluteCompare(i, _))
          return i;
        const t = _.__unsignedDigit(0);
        if (1 === _.length && 32767 >= t) {
          if (1 === t)
            return _JSBI.__zero();
          const _2 = _JSBI.__absoluteModSmall(i, t);
          return 0 === _2 ? _JSBI.__zero() : _JSBI.__oneDigit(_2, i.sign);
        }
        const e = _JSBI.__absoluteDivLarge(i, _, false, true);
        return e.sign = i.sign, e.__trim();
      }
      static add(i, _) {
        const t = i.sign;
        return t === _.sign ? _JSBI.__absoluteAdd(i, _, t) : 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t);
      }
      static subtract(i, _) {
        const t = i.sign;
        return t === _.sign ? 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t) : _JSBI.__absoluteAdd(i, _, t);
      }
      static leftShift(i, _) {
        return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__rightShiftByAbsolute(i, _) : _JSBI.__leftShiftByAbsolute(i, _);
      }
      static signedRightShift(i, _) {
        return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__leftShiftByAbsolute(i, _) : _JSBI.__rightShiftByAbsolute(i, _);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i, _) {
        return 0 > _JSBI.__compareToBigInt(i, _);
      }
      static lessThanOrEqual(i, _) {
        return 0 >= _JSBI.__compareToBigInt(i, _);
      }
      static greaterThan(i, _) {
        return 0 < _JSBI.__compareToBigInt(i, _);
      }
      static greaterThanOrEqual(i, _) {
        return 0 <= _JSBI.__compareToBigInt(i, _);
      }
      static equal(_, t) {
        if (_.sign !== t.sign)
          return false;
        if (_.length !== t.length)
          return false;
        for (let e = 0; e < _.length; e++)
          if (_.__digit(e) !== t.__digit(e))
            return false;
        return true;
      }
      static notEqual(i, _) {
        return !_JSBI.equal(i, _);
      }
      static bitwiseAnd(i, _) {
        var t = Math.max;
        if (!i.sign && !_.sign)
          return _JSBI.__absoluteAnd(i, _).__trim();
        if (i.sign && _.sign) {
          const e = t(i.length, _.length) + 1;
          let n = _JSBI.__absoluteSubOne(i, e);
          const g = _JSBI.__absoluteSubOne(_);
          return n = _JSBI.__absoluteOr(n, g, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
        }
        return i.sign && ([i, _] = [_, i]), _JSBI.__absoluteAndNot(i, _JSBI.__absoluteSubOne(_)).__trim();
      }
      static bitwiseXor(i, _) {
        var t = Math.max;
        if (!i.sign && !_.sign)
          return _JSBI.__absoluteXor(i, _).__trim();
        if (i.sign && _.sign) {
          const e2 = t(i.length, _.length), n2 = _JSBI.__absoluteSubOne(i, e2), g = _JSBI.__absoluteSubOne(_);
          return _JSBI.__absoluteXor(n2, g, n2).__trim();
        }
        const e = t(i.length, _.length) + 1;
        i.sign && ([i, _] = [_, i]);
        let n = _JSBI.__absoluteSubOne(_, e);
        return n = _JSBI.__absoluteXor(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
      }
      static bitwiseOr(i, _) {
        var t = Math.max;
        const e = t(i.length, _.length);
        if (!i.sign && !_.sign)
          return _JSBI.__absoluteOr(i, _).__trim();
        if (i.sign && _.sign) {
          let t2 = _JSBI.__absoluteSubOne(i, e);
          const n2 = _JSBI.__absoluteSubOne(_);
          return t2 = _JSBI.__absoluteAnd(t2, n2, t2), _JSBI.__absoluteAddOne(t2, true, t2).__trim();
        }
        i.sign && ([i, _] = [_, i]);
        let n = _JSBI.__absoluteSubOne(_, e);
        return n = _JSBI.__absoluteAndNot(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
      }
      static asIntN(_, t) {
        var i = Math.floor;
        if (0 === t.length)
          return t;
        if (_ = i(_), 0 > _)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _)
          return _JSBI.__zero();
        if (_ >= _JSBI.__kMaxLengthBits)
          return t;
        const e = 0 | (_ + 29) / 30;
        if (t.length < e)
          return t;
        const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
        if (t.length === e && g < o)
          return t;
        if (!((g & o) === o))
          return _JSBI.__truncateToNBits(_, t);
        if (!t.sign)
          return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, true);
        if (0 == (g & o - 1)) {
          for (let n = e - 2; 0 <= n; n--)
            if (0 !== t.__digit(n))
              return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
          return t.length === e && g === o ? t : _JSBI.__truncateToNBits(_, t);
        }
        return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
      }
      static asUintN(i, _) {
        var t = Math.floor;
        if (0 === _.length)
          return _;
        if (i = t(i), 0 > i)
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i)
          return _JSBI.__zero();
        if (_.sign) {
          if (i > _JSBI.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          return _JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
        }
        if (i >= _JSBI.__kMaxLengthBits)
          return _;
        const e = 0 | (i + 29) / 30;
        if (_.length < e)
          return _;
        const g = i % 30;
        if (_.length == e) {
          if (0 === g)
            return _;
          const i2 = _.__digit(e - 1);
          if (0 == i2 >>> g)
            return _;
        }
        return _JSBI.__truncateToNBits(i, _);
      }
      static ADD(i, _) {
        if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i)
          return "string" != typeof _ && (_ = _.toString()), i + _;
        if ("string" == typeof _)
          return i.toString() + _;
        if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i) && _JSBI.__isBigInt(_))
          return _JSBI.add(i, _);
        if ("number" == typeof i && "number" == typeof _)
          return i + _;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i, _) {
        return _JSBI.__compare(i, _, 0);
      }
      static LE(i, _) {
        return _JSBI.__compare(i, _, 1);
      }
      static GT(i, _) {
        return _JSBI.__compare(i, _, 2);
      }
      static GE(i, _) {
        return _JSBI.__compare(i, _, 3);
      }
      static EQ(i, _) {
        for (; ; ) {
          if (_JSBI.__isBigInt(i))
            return _JSBI.__isBigInt(_) ? _JSBI.equal(i, _) : _JSBI.EQ(_, i);
          if ("number" == typeof i) {
            if (_JSBI.__isBigInt(_))
              return _JSBI.__equalToNumber(_, i);
            if ("object" != typeof _)
              return i == _;
            _ = _JSBI.__toPrimitive(_);
          } else if ("string" == typeof i) {
            if (_JSBI.__isBigInt(_))
              return i = _JSBI.__fromString(i), null !== i && _JSBI.equal(i, _);
            if ("object" != typeof _)
              return i == _;
            _ = _JSBI.__toPrimitive(_);
          } else if ("boolean" == typeof i) {
            if (_JSBI.__isBigInt(_))
              return _JSBI.__equalToNumber(_, +i);
            if ("object" != typeof _)
              return i == _;
            _ = _JSBI.__toPrimitive(_);
          } else if ("symbol" == typeof i) {
            if (_JSBI.__isBigInt(_))
              return false;
            if ("object" != typeof _)
              return i == _;
            _ = _JSBI.__toPrimitive(_);
          } else if ("object" == typeof i) {
            if ("object" == typeof _ && _.constructor !== _JSBI)
              return i == _;
            i = _JSBI.__toPrimitive(i);
          } else
            return i == _;
        }
      }
      static NE(i, _) {
        return !_JSBI.EQ(i, _);
      }
      static __zero() {
        return new _JSBI(0, false);
      }
      static __oneDigit(i, _) {
        const t = new _JSBI(1, _);
        return t.__setDigit(0, i), t;
      }
      __copy() {
        const _ = new _JSBI(this.length, this.sign);
        for (let t = 0; t < this.length; t++)
          _[t] = this[t];
        return _;
      }
      __trim() {
        let i = this.length, _ = this[i - 1];
        for (; 0 === _; )
          i--, _ = this[i - 1], this.pop();
        return 0 === i && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _ = 0; _ < this.length; _++)
          this[_] = 0;
      }
      static __decideRounding(i, _, t, e) {
        if (0 < _)
          return -1;
        let n;
        if (0 > _)
          n = -_ - 1;
        else {
          if (0 === t)
            return -1;
          t--, e = i.__digit(t), n = 29;
        }
        let g = 1 << n;
        if (0 == (e & g))
          return -1;
        if (g -= 1, 0 != (e & g))
          return 1;
        for (; 0 < t; )
          if (t--, 0 !== i.__digit(t))
            return 1;
        return 0;
      }
      static __fromDouble(i) {
        _JSBI.__kBitConversionDouble[0] = i;
        const _ = 2047 & _JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new _JSBI(e, 0 > i);
        let g = 1048575 & _JSBI.__kBitConversionInts[1] | 1048576, o = _JSBI.__kBitConversionInts[0];
        const s = 20, l = t % 30;
        let r, a = 0;
        if (l < 20) {
          const i2 = s - l;
          a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
        } else if (l === 20)
          a = 32, r = g, g = o, o = 0;
        else {
          const i2 = l - s;
          a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
        }
        n.__setDigit(e - 1, r);
        for (let _2 = e - 2; 0 <= _2; _2--)
          0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
        return n.__trim();
      }
      static __isWhitespace(i) {
        return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
      }
      static __fromString(i, _ = 0) {
        let t = 0;
        const e = i.length;
        let n = 0;
        if (n === e)
          return _JSBI.__zero();
        let g = i.charCodeAt(n);
        for (; _JSBI.__isWhitespace(g); ) {
          if (++n === e)
            return _JSBI.__zero();
          g = i.charCodeAt(n);
        }
        if (43 === g) {
          if (++n === e)
            return null;
          g = i.charCodeAt(n), t = 1;
        } else if (45 === g) {
          if (++n === e)
            return null;
          g = i.charCodeAt(n), t = -1;
        }
        if (0 === _) {
          if (_ = 10, 48 === g) {
            if (++n === e)
              return _JSBI.__zero();
            if (g = i.charCodeAt(n), 88 === g || 120 === g) {
              if (_ = 16, ++n === e)
                return null;
              g = i.charCodeAt(n);
            } else if (79 === g || 111 === g) {
              if (_ = 8, ++n === e)
                return null;
              g = i.charCodeAt(n);
            } else if (66 === g || 98 === g) {
              if (_ = 2, ++n === e)
                return null;
              g = i.charCodeAt(n);
            }
          }
        } else if (16 === _ && 48 === g) {
          if (++n === e)
            return _JSBI.__zero();
          if (g = i.charCodeAt(n), 88 === g || 120 === g) {
            if (++n === e)
              return null;
            g = i.charCodeAt(n);
          }
        }
        if (0 != t && 10 !== _)
          return null;
        for (; 48 === g; ) {
          if (++n === e)
            return _JSBI.__zero();
          g = i.charCodeAt(n);
        }
        const o = e - n;
        let s = _JSBI.__kMaxBitsPerChar[_], l = _JSBI.__kBitsPerCharTableMultiplier - 1;
        if (o > 1073741824 / s)
          return null;
        const r = s * o + l >>> _JSBI.__kBitsPerCharTableShift, a = new _JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
        if (0 == (_ & _ - 1)) {
          s >>= _JSBI.__kBitsPerCharTableShift;
          const _2 = [], t2 = [];
          let o2 = false;
          do {
            let l2 = 0, r2 = 0;
            for (; ; ) {
              let _3;
              if (g - 48 >>> 0 < u)
                _3 = g - 48;
              else if ((32 | g) - 97 >>> 0 < h)
                _3 = (32 | g) - 87;
              else {
                o2 = true;
                break;
              }
              if (r2 += s, l2 = l2 << s | _3, ++n === e) {
                o2 = true;
                break;
              }
              if (g = i.charCodeAt(n), 30 < r2 + s)
                break;
            }
            _2.push(l2), t2.push(r2);
          } while (!o2);
          _JSBI.__fillFromParts(a, _2, t2);
        } else {
          a.__initializeDigits();
          let t2 = false, o2 = 0;
          do {
            let r2 = 0, b = 1;
            for (; ; ) {
              let s2;
              if (g - 48 >>> 0 < u)
                s2 = g - 48;
              else if ((32 | g) - 97 >>> 0 < h)
                s2 = (32 | g) - 87;
              else {
                t2 = true;
                break;
              }
              const l2 = b * _;
              if (1073741823 < l2)
                break;
              if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
                t2 = true;
                break;
              }
              g = i.charCodeAt(n);
            }
            l = 30 * _JSBI.__kBitsPerCharTableMultiplier - 1;
            const D = 0 | (s * o2 + l >>> _JSBI.__kBitsPerCharTableShift) / 30;
            a.__inplaceMultiplyAdd(b, r2, D);
          } while (!t2);
        }
        if (n !== e) {
          if (!_JSBI.__isWhitespace(g))
            return null;
          for (n++; n < e; n++)
            if (g = i.charCodeAt(n), !_JSBI.__isWhitespace(g))
              return null;
        }
        return a.sign = -1 == t, a.__trim();
      }
      static __fillFromParts(_, t, e) {
        let n = 0, g = 0, o = 0;
        for (let s = t.length - 1; 0 <= s; s--) {
          const i = t[s], l = e[s];
          g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
        }
        if (0 !== g) {
          if (n >= _.length)
            throw new Error("implementation bug");
          _.__setDigit(n++, g);
        }
        for (; n < _.length; n++)
          _.__setDigit(n, 0);
      }
      static __toStringBasePowerOfTwo(_, i) {
        const t = _.length;
        let e = i - 1;
        e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
        const n = e, g = i - 1, o = _.__digit(t - 1), s = _JSBI.__clz30(o);
        let l = 0 | (30 * t - s + n - 1) / n;
        if (_.sign && l++, 268435456 < l)
          throw new Error("string too long");
        const r = Array(l);
        let a = l - 1, u = 0, d = 0;
        for (let e2 = 0; e2 < t - 1; e2++) {
          const i2 = _.__digit(e2), t2 = (u | i2 << d) & g;
          r[a--] = _JSBI.__kConversionChars[t2];
          const o2 = n - d;
          for (u = i2 >>> o2, d = 30 - o2; d >= n; )
            r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
        }
        const h = (u | o << d) & g;
        for (r[a--] = _JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u; )
          r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n;
        if (_.sign && (r[a--] = "-"), -1 != a)
          throw new Error("implementation bug");
        return r.join("");
      }
      static __toStringGeneric(_, i, t) {
        const e = _.length;
        if (0 === e)
          return "";
        if (1 === e) {
          let e2 = _.__unsignedDigit(0).toString(i);
          return false === t && _.sign && (e2 = "-" + e2), e2;
        }
        const n = 30 * e - _JSBI.__clz30(_.__digit(e - 1)), g = _JSBI.__kMaxBitsPerChar[i], o = g - 1;
        let s = n * _JSBI.__kBitsPerCharTableMultiplier;
        s += o - 1, s = 0 | s / o;
        const l = s + 1 >> 1, r = _JSBI.exponentiate(_JSBI.__oneDigit(i, false), _JSBI.__oneDigit(l, false));
        let a, u;
        const d = r.__unsignedDigit(0);
        if (1 === r.length && 32767 >= d) {
          a = new _JSBI(_.length, false), a.__initializeDigits();
          let t2 = 0;
          for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
            const i2 = t2 << 15 | _.__halfDigit(e2);
            a.__setHalfDigit(e2, 0 | i2 / d), t2 = 0 | i2 % d;
          }
          u = t2.toString(i);
        } else {
          const t2 = _JSBI.__absoluteDivLarge(_, r, true, true);
          a = t2.quotient;
          const e2 = t2.remainder.__trim();
          u = _JSBI.__toStringGeneric(e2, i, true);
        }
        a.__trim();
        let h = _JSBI.__toStringGeneric(a, i, true);
        for (; u.length < l; )
          u = "0" + u;
        return false === t && _.sign && (h = "-" + h), h + u;
      }
      static __unequalSign(i) {
        return i ? -1 : 1;
      }
      static __absoluteGreater(i) {
        return i ? -1 : 1;
      }
      static __absoluteLess(i) {
        return i ? 1 : -1;
      }
      static __compareToBigInt(i, _) {
        const t = i.sign;
        if (t !== _.sign)
          return _JSBI.__unequalSign(t);
        const e = _JSBI.__absoluteCompare(i, _);
        return 0 < e ? _JSBI.__absoluteGreater(t) : 0 > e ? _JSBI.__absoluteLess(t) : 0;
      }
      static __compareToNumber(i, _) {
        if (_JSBI.__isOneDigitInt(_)) {
          const t = i.sign, e = 0 > _;
          if (t !== e)
            return _JSBI.__unequalSign(t);
          if (0 === i.length) {
            if (e)
              throw new Error("implementation bug");
            return 0 === _ ? 0 : -1;
          }
          if (1 < i.length)
            return _JSBI.__absoluteGreater(t);
          const n = Math.abs(_), g = i.__unsignedDigit(0);
          return g > n ? _JSBI.__absoluteGreater(t) : g < n ? _JSBI.__absoluteLess(t) : 0;
        }
        return _JSBI.__compareToDouble(i, _);
      }
      static __compareToDouble(i, _) {
        if (_ !== _)
          return _;
        if (_ === 1 / 0)
          return -1;
        if (_ === -Infinity)
          return 1;
        const t = i.sign;
        if (t !== 0 > _)
          return _JSBI.__unequalSign(t);
        if (0 === _)
          throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i.length)
          return -1;
        _JSBI.__kBitConversionDouble[0] = _;
        const e = 2047 & _JSBI.__kBitConversionInts[1] >>> 20;
        if (2047 == e)
          throw new Error("implementation bug: handled elsewhere");
        const n = e - 1023;
        if (0 > n)
          return _JSBI.__absoluteGreater(t);
        const g = i.length;
        let o = i.__digit(g - 1);
        const s = _JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
        if (l < r)
          return _JSBI.__absoluteLess(t);
        if (l > r)
          return _JSBI.__absoluteGreater(t);
        let a = 1048576 | 1048575 & _JSBI.__kBitConversionInts[1], u = _JSBI.__kBitConversionInts[0];
        const d = 20, h = 29 - s;
        if (h !== (0 | (l - 1) % 30))
          throw new Error("implementation bug");
        let m, b = 0;
        if (20 > h) {
          const i2 = d - h;
          b = i2 + 32, m = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
        } else if (20 === h)
          b = 32, m = a, a = u, u = 0;
        else {
          const i2 = h - d;
          b = 32 - i2, m = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
        }
        if (o >>>= 0, m >>>= 0, o > m)
          return _JSBI.__absoluteGreater(t);
        if (o < m)
          return _JSBI.__absoluteLess(t);
        for (let e2 = g - 2; 0 <= e2; e2--) {
          0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
          const _2 = i.__unsignedDigit(e2);
          if (_2 > m)
            return _JSBI.__absoluteGreater(t);
          if (_2 < m)
            return _JSBI.__absoluteLess(t);
        }
        if (0 !== a || 0 !== u) {
          if (0 === b)
            throw new Error("implementation bug");
          return _JSBI.__absoluteLess(t);
        }
        return 0;
      }
      static __equalToNumber(i, _) {
        var t = Math.abs;
        return _JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === _JSBI.__compareToDouble(i, _);
      }
      static __comparisonResultToBool(i, _) {
        return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
      }
      static __compare(i, _, t) {
        if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _)
          switch (t) {
            case 0:
              return i < _;
            case 1:
              return i <= _;
            case 2:
              return i > _;
            case 3:
              return i >= _;
          }
        if (_JSBI.__isBigInt(i) && "string" == typeof _)
          return _ = _JSBI.__fromString(_), null !== _ && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
        if ("string" == typeof i && _JSBI.__isBigInt(_))
          return i = _JSBI.__fromString(i), null !== i && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
        if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i)) {
          if (_JSBI.__isBigInt(_))
            return _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
          if ("number" != typeof _)
            throw new Error("implementation bug");
          return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(i, _), t);
        }
        if ("number" != typeof i)
          throw new Error("implementation bug");
        if (_JSBI.__isBigInt(_))
          return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(_, i), 2 ^ t);
        if ("number" != typeof _)
          throw new Error("implementation bug");
        return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;
      }
      __clzmsd() {
        return _JSBI.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_, t, e) {
        if (_.length < t.length)
          return _JSBI.__absoluteAdd(t, _, e);
        if (0 === _.length)
          return _;
        if (0 === t.length)
          return _.sign === e ? _ : _JSBI.unaryMinus(_);
        let n = _.length;
        (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;
        const g = new _JSBI(n, e);
        let o = 0, s = 0;
        for (; s < t.length; s++) {
          const i = _.__digit(s) + t.__digit(s) + o;
          o = i >>> 30, g.__setDigit(s, 1073741823 & i);
        }
        for (; s < _.length; s++) {
          const i = _.__digit(s) + o;
          o = i >>> 30, g.__setDigit(s, 1073741823 & i);
        }
        return s < g.length && g.__setDigit(s, o), g.__trim();
      }
      static __absoluteSub(_, t, e) {
        if (0 === _.length)
          return _;
        if (0 === t.length)
          return _.sign === e ? _ : _JSBI.unaryMinus(_);
        const n = new _JSBI(_.length, e);
        let g = 0, o = 0;
        for (; o < t.length; o++) {
          const i = _.__digit(o) - t.__digit(o) - g;
          g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        for (; o < _.length; o++) {
          const i = _.__digit(o) - g;
          g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        return n.__trim();
      }
      static __absoluteAddOne(_, i, t = null) {
        const e = _.length;
        null === t ? t = new _JSBI(e, i) : t.sign = i;
        let n = 1;
        for (let g = 0; g < e; g++) {
          const i2 = _.__digit(g) + n;
          n = i2 >>> 30, t.__setDigit(g, 1073741823 & i2);
        }
        return 0 != n && t.__setDigitGrow(e, 1), t;
      }
      static __absoluteSubOne(_, t) {
        const e = _.length;
        t = t || e;
        const n = new _JSBI(t, false);
        let g = 1;
        for (let o = 0; o < e; o++) {
          const i = _.__digit(o) - g;
          g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
        }
        if (0 != g)
          throw new Error("implementation bug");
        for (let g2 = e; g2 < t; g2++)
          n.__setDigit(g2, 0);
        return n;
      }
      static __absoluteAnd(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
          o = n;
          const i = _, e2 = n;
          _ = t, n = g, t = i, g = e2;
        }
        let s = o;
        null === e ? e = new _JSBI(s, false) : s = e.length;
        let l = 0;
        for (; l < o; l++)
          e.__setDigit(l, _.__digit(l) & t.__digit(l));
        for (; l < s; l++)
          e.__setDigit(l, 0);
        return e;
      }
      static __absoluteAndNot(_, t, e = null) {
        const n = _.length, g = t.length;
        let o = g;
        n < g && (o = n);
        let s = n;
        null === e ? e = new _JSBI(s, false) : s = e.length;
        let l = 0;
        for (; l < o; l++)
          e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
        for (; l < n; l++)
          e.__setDigit(l, _.__digit(l));
        for (; l < s; l++)
          e.__setDigit(l, 0);
        return e;
      }
      static __absoluteOr(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
          o = n;
          const i = _, e2 = n;
          _ = t, n = g, t = i, g = e2;
        }
        let s = n;
        null === e ? e = new _JSBI(s, false) : s = e.length;
        let l = 0;
        for (; l < o; l++)
          e.__setDigit(l, _.__digit(l) | t.__digit(l));
        for (; l < n; l++)
          e.__setDigit(l, _.__digit(l));
        for (; l < s; l++)
          e.__setDigit(l, 0);
        return e;
      }
      static __absoluteXor(_, t, e = null) {
        let n = _.length, g = t.length, o = g;
        if (n < g) {
          o = n;
          const i = _, e2 = n;
          _ = t, n = g, t = i, g = e2;
        }
        let s = n;
        null === e ? e = new _JSBI(s, false) : s = e.length;
        let l = 0;
        for (; l < o; l++)
          e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
        for (; l < n; l++)
          e.__setDigit(l, _.__digit(l));
        for (; l < s; l++)
          e.__setDigit(l, 0);
        return e;
      }
      static __absoluteCompare(_, t) {
        const e = _.length - t.length;
        if (0 != e)
          return e;
        let n = _.length - 1;
        for (; 0 <= n && _.__digit(n) === t.__digit(n); )
          n--;
        return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
      }
      static __multiplyAccumulate(_, t, e, n) {
        if (0 === t)
          return;
        const g = 32767 & t, o = t >>> 15;
        let s = 0, l = 0;
        for (let r, a = 0; a < _.length; a++, n++) {
          r = e.__digit(n);
          const i = _.__digit(a), t2 = 32767 & i, u = i >>> 15, d = _JSBI.__imul(t2, g), h = _JSBI.__imul(t2, o), m = _JSBI.__imul(u, g), b = _JSBI.__imul(u, o);
          r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
        }
        for (; 0 != s || 0 !== l; n++) {
          let i = e.__digit(n);
          i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
        }
      }
      static __internalMultiplyAdd(_, t, e, g, o) {
        let s = e, l = 0;
        for (let n = 0; n < g; n++) {
          const i = _.__digit(n), e2 = _JSBI.__imul(32767 & i, t), g2 = _JSBI.__imul(i >>> 15, t), a = e2 + ((32767 & g2) << 15) + l + s;
          s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
        }
        if (o.length > g)
          for (o.__setDigit(g++, s + l); g < o.length; )
            o.__setDigit(g++, 0);
        else if (0 !== s + l)
          throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i, _, t) {
        t > this.length && (t = this.length);
        const e = 32767 & i, n = i >>> 15;
        let g = 0, o = _;
        for (let s = 0; s < t; s++) {
          const i2 = this.__digit(s), _2 = 32767 & i2, t2 = i2 >>> 15, l = _JSBI.__imul(_2, e), r = _JSBI.__imul(_2, n), a = _JSBI.__imul(t2, e), u = _JSBI.__imul(t2, n);
          let d = o + l + g;
          g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
        }
        if (0 != g || 0 !== o)
          throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_, t, e = null) {
        null === e && (e = new _JSBI(_.length, false));
        let n = 0;
        for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
          g = (n << 15 | _.__halfDigit(o)) >>> 0;
          const i = 0 | g / t;
          n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
          const s = 0 | g / t;
          n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
        }
        return e;
      }
      static __absoluteModSmall(_, t) {
        let e = 0;
        for (let n = 2 * _.length - 1; 0 <= n; n--) {
          const i = (e << 15 | _.__halfDigit(n)) >>> 0;
          e = 0 | i % t;
        }
        return e;
      }
      static __absoluteDivLarge(i, _, t, e) {
        const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
        let s = null;
        t && (s = new _JSBI(o + 2 >>> 1, false), s.__initializeDigits());
        const l = new _JSBI(g + 2 >>> 1, false);
        l.__initializeDigits();
        const r = _JSBI.__clz15(_.__halfDigit(g - 1));
        0 < r && (_ = _JSBI.__specialLeftShift(_, r, 0));
        const a = _JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
        let d = 0;
        for (let r2, h = o; 0 <= h; h--) {
          r2 = 32767;
          const i2 = a.__halfDigit(h + g);
          if (i2 !== u) {
            const t2 = (i2 << 15 | a.__halfDigit(h + g - 1)) >>> 0;
            r2 = 0 | t2 / u;
            let e3 = 0 | t2 % u;
            const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h + g - 2);
            for (; _JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); )
              ;
          }
          _JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
          let e2 = a.__inplaceSub(l, h, g + 1);
          0 !== e2 && (e2 = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e2), r2--), t && (1 & h ? d = r2 << 15 : s.__setDigit(h >>> 1, d | r2));
        }
        if (e)
          return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a;
        if (t)
          return s;
        throw new Error("unreachable");
      }
      static __clz15(i) {
        return _JSBI.__clz30(i) - 15;
      }
      __inplaceAdd(_, t, e) {
        let n = 0;
        for (let g = 0; g < e; g++) {
          const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
          n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
        }
        return n;
      }
      __inplaceSub(_, t, e) {
        let n = 0;
        if (1 & t) {
          t >>= 1;
          let g = this.__digit(t), o = 32767 & g, s = 0;
          for (; s < e - 1 >>> 1; s++) {
            const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
            n = 1 & e2 >>> 15, this.__setDigit(t + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
          }
          const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
          n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
          if (t + s + 1 >= this.length)
            throw new RangeError("out of bounds");
          0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
        } else {
          t >>= 1;
          let g = 0;
          for (; g < _.length - 1; g++) {
            const i2 = this.__digit(t + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
            n = 1 & o2 >>> 15;
            const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
            n = 1 & s2 >>> 15, this.__setDigit(t + g, (32767 & s2) << 15 | 32767 & o2);
          }
          const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
          n = 1 & s >>> 15;
          let l = 0;
          0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
        }
        return n;
      }
      __inplaceRightShift(_) {
        if (0 === _)
          return;
        let t = this.__digit(0) >>> _;
        const e = this.length - 1;
        for (let n = 0; n < e; n++) {
          const i = this.__digit(n + 1);
          this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
        }
        this.__setDigit(e, t);
      }
      static __specialLeftShift(_, t, e) {
        const g = _.length, n = new _JSBI(g + e, false);
        if (0 === t) {
          for (let t2 = 0; t2 < g; t2++)
            n.__setDigit(t2, _.__digit(t2));
          return 0 < e && n.__setDigit(g, 0), n;
        }
        let o = 0;
        for (let s = 0; s < g; s++) {
          const i = _.__digit(s);
          n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
        }
        return 0 < e && n.__setDigit(g, o), n;
      }
      static __leftShiftByAbsolute(_, i) {
        const t = _JSBI.__toShiftAmount(i);
        if (0 > t)
          throw new RangeError("BigInt too big");
        const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new _JSBI(s, _.sign);
        if (0 === n) {
          let t2 = 0;
          for (; t2 < e; t2++)
            l.__setDigit(t2, 0);
          for (; t2 < s; t2++)
            l.__setDigit(t2, _.__digit(t2 - e));
        } else {
          let t2 = 0;
          for (let _2 = 0; _2 < e; _2++)
            l.__setDigit(_2, 0);
          for (let o2 = 0; o2 < g; o2++) {
            const i2 = _.__digit(o2);
            l.__setDigit(o2 + e, 1073741823 & i2 << n | t2), t2 = i2 >>> 30 - n;
          }
          if (o)
            l.__setDigit(g + e, t2);
          else if (0 !== t2)
            throw new Error("implementation bug");
        }
        return l.__trim();
      }
      static __rightShiftByAbsolute(_, i) {
        const t = _.length, e = _.sign, n = _JSBI.__toShiftAmount(i);
        if (0 > n)
          return _JSBI.__rightShiftByMaximum(e);
        const g = 0 | n / 30, o = n % 30;
        let s = t - g;
        if (0 >= s)
          return _JSBI.__rightShiftByMaximum(e);
        let l = false;
        if (e) {
          if (0 != (_.__digit(g) & (1 << o) - 1))
            l = true;
          else
            for (let t2 = 0; t2 < g; t2++)
              if (0 !== _.__digit(t2)) {
                l = true;
                break;
              }
        }
        if (l && 0 === o) {
          const i2 = _.__digit(t - 1);
          0 == ~i2 && s++;
        }
        let r = new _JSBI(s, e);
        if (0 === o) {
          r.__setDigit(s - 1, 0);
          for (let e2 = g; e2 < t; e2++)
            r.__setDigit(e2 - g, _.__digit(e2));
        } else {
          let e2 = _.__digit(g) >>> o;
          const n2 = t - g - 1;
          for (let t2 = 0; t2 < n2; t2++) {
            const i2 = _.__digit(t2 + g + 1);
            r.__setDigit(t2, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
          }
          r.__setDigit(n2, e2);
        }
        return l && (r = _JSBI.__absoluteAddOne(r, true, r)), r.__trim();
      }
      static __rightShiftByMaximum(i) {
        return i ? _JSBI.__oneDigit(1, true) : _JSBI.__zero();
      }
      static __toShiftAmount(i) {
        if (1 < i.length)
          return -1;
        const _ = i.__unsignedDigit(0);
        return _ > _JSBI.__kMaxLengthBits ? -1 : _;
      }
      static __toPrimitive(i, _ = "default") {
        if ("object" != typeof i)
          return i;
        if (i.constructor === _JSBI)
          return i;
        if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
          const t2 = i[Symbol.toPrimitive];
          if (t2) {
            const i2 = t2(_);
            if ("object" != typeof i2)
              return i2;
            throw new TypeError("Cannot convert object to primitive value");
          }
        }
        const t = i.valueOf;
        if (t) {
          const _2 = t.call(i);
          if ("object" != typeof _2)
            return _2;
        }
        const e = i.toString;
        if (e) {
          const _2 = e.call(i);
          if ("object" != typeof _2)
            return _2;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i) {
        return _JSBI.__isBigInt(i) ? i : +i;
      }
      static __isBigInt(i) {
        return "object" == typeof i && null !== i && i.constructor === _JSBI;
      }
      static __truncateToNBits(i, _) {
        const t = 0 | (i + 29) / 30, e = new _JSBI(t, _.sign), n = t - 1;
        for (let t2 = 0; t2 < n; t2++)
          e.__setDigit(t2, _.__digit(t2));
        let g = _.__digit(n);
        if (0 != i % 30) {
          const _2 = 32 - i % 30;
          g = g << _2 >>> _2;
        }
        return e.__setDigit(n, g), e.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_, t, e) {
        var n = Math.min;
        const g = 0 | (_ + 29) / 30, o = new _JSBI(g, e);
        let s = 0;
        const l = g - 1;
        let a = 0;
        for (const i = n(l, t.length); s < i; s++) {
          const i2 = 0 - t.__digit(s) - a;
          a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
        }
        for (; s < l; s++)
          o.__setDigit(s, 0 | 1073741823 & -a);
        let u = l < t.length ? t.__digit(l) : 0;
        const d = _ % 30;
        let h;
        if (0 == d)
          h = 0 - u - a, h &= 1073741823;
        else {
          const i = 32 - d;
          u = u << i >>> i;
          const _2 = 1 << 32 - i;
          h = _2 - u - a, h &= _2 - 1;
        }
        return o.__setDigit(l, h), o.__trim();
      }
      __digit(_) {
        return this[_];
      }
      __unsignedDigit(_) {
        return this[_] >>> 0;
      }
      __setDigit(_, i) {
        this[_] = 0 | i;
      }
      __setDigitGrow(_, i) {
        this[_] = 0 | i;
      }
      __halfDigitLength() {
        const i = this.length;
        return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
      }
      __halfDigit(_) {
        return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
      }
      __setHalfDigit(_, i) {
        const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
        this.__setDigit(t, n);
      }
      static __digitPow(i, _) {
        let t = 1;
        for (; 0 < _; )
          1 & _ && (t *= i), _ >>>= 1, i *= i;
        return t;
      }
      static __isOneDigitInt(i) {
        return (1073741823 & i) === i;
      }
    };
    JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
      return Math.clz32(i) - 2;
    } : function(i) {
      return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
    }, JSBI.__imul = Math.imul || function(i, _) {
      return 0 | i * _;
    };
    jsbi_default = JSBI;
  }
});

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
var isProduction, prefix;
var init_tiny_invariant = __esm({
  "node_modules/tiny-invariant/dist/esm/tiny-invariant.js"() {
    isProduction = false;
    prefix = "Invariant failed";
  }
});

// node_modules/decimal.js-light/decimal.mjs
function add(x, y) {
  var carry, d, e, i, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (!y.s)
      y = new Ctor(x);
    return external ? round(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  k = x.e;
  e = y.e;
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = e;
  return external ? round(y, pr) : y;
}
function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function exp(x, sd) {
  var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x) > 16)
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  if (!x.s)
    return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.abs().gte(0.1)) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow = round(pow.times(x), wpr);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k--)
        sum = round(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t;
  }
}
function getBase10Exponent(x) {
  var e = x.e * LOG_BASE, w = x.d[0];
  for (; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function ln(y, sd) {
  var c, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
  if (x.s < 1)
    throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE))
    return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x.eq(10)) {
    if (sd == null)
      external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  e = getBase10Exponent(x);
  if (Math.abs(e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = getBase10Exponent(x);
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? (external = true, round(x, pr)) : x;
  }
  sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
  x2 = round(x.times(x), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round(numerator.times(x2), wpr);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t;
    denominator += 2;
  }
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; )
    ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; )
    --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e = e - i - 1;
    x.e = mathfloor(e / LOG_BASE);
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external && (x.e > MAX_E || x.e < -MAX_E))
      throw Error(exponentOutOfRange + e);
  } else {
    x.s = 0;
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function round(x, sd, rm) {
  var i, j, k, n, rd, doRound, w, xdi, xd = x.d;
  for (n = 1, k = xd[0]; k >= 10; k /= 10)
    n++;
  i = sd - n;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k = xd.length;
    if (xdi >= k)
      return x;
    w = k = xd[xdi];
    for (n = 1; k >= 10; k /= 10)
      n++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n;
  }
  if (rm !== void 0) {
    k = mathpow(10, n - j - 1);
    rd = w / k % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k = getBase10Exponent(x);
      xd.length = 1;
      sd = sd - k - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x.e = x.s = 0;
    }
    return x;
  }
  if (i == 0) {
    xd.length = xdi;
    k = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k) == BASE) {
          xd[0] = 1;
          ++x.e;
        }
        break;
      } else {
        xd[xdi] += k;
        if (xd[xdi] != BASE)
          break;
        xd[xdi--] = 0;
        k = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; )
    xd.pop();
  if (external && (x.e > MAX_E || x.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  }
  return x;
}
function subtract(x, y) {
  var d, e, i, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (y.s)
      y.s = -y.s;
    else
      y = new Ctor(x);
    return external ? round(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  e = y.e;
  xe = x.e;
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(0);
  y.d = xd;
  y.e = e;
  return external ? round(y, pr) : y;
}
function toString(x, isExp, sd) {
  var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(value) {
    var x = this;
    if (!(x instanceof Decimal3))
      return new Decimal3(value);
    x.constructor = Decimal3;
    if (value instanceof Decimal3) {
      x.s = value.s;
      x.e = value.e;
      x.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x.s = 1;
      } else if (value < 0) {
        value = -value;
        x.s = -1;
      } else {
        x.s = 0;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x.e = 0;
        x.d = [value];
        return;
      }
      return parseDecimal(x, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }
    if (isDecimal.test(value))
      parseDecimal(x, value);
    else
      throw Error(invalidArgument + value);
  }
  Decimal3.prototype = P;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.clone = clone;
  Decimal3.config = Decimal3.set = config;
  if (obj === void 0)
    obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; )
      if (!obj.hasOwnProperty(p = ps[i++]))
        obj[p] = this[p];
  }
  Decimal3.config(obj);
  return Decimal3;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if ((v = obj[p = "LN10"]) !== void 0) {
    if (v == Math.LN10)
      this[p] = new this(v);
    else
      throw Error(invalidArgument + p + ": " + v);
  }
  return this;
}
var MAX_DIGITS, defaults, Decimal, external, decimalError, invalidArgument, exponentOutOfRange, mathfloor, mathpow, isDecimal, ONE, BASE, LOG_BASE, MAX_SAFE_INTEGER, MAX_E, P, divide, Decimal, decimal_default;
var init_decimal = __esm({
  "node_modules/decimal.js-light/decimal.mjs"() {
    MAX_DIGITS = 1e9;
    defaults = {
      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed during run-time using `Decimal.config`.
      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,
      // 1 to MAX_DIGITS
      // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
      // `toFixed`, `toPrecision` and `toSignificantDigits`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,
      // 0 to 8
      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,
      // 0 to -MAX_E
      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos: 21,
      // 0 to MAX_E
      // The natural logarithm of 10.
      // 115 digits
      LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
    };
    external = true;
    decimalError = "[DecimalError] ";
    invalidArgument = decimalError + "Invalid argument: ";
    exponentOutOfRange = decimalError + "Exponent out of range: ";
    mathfloor = Math.floor;
    mathpow = Math.pow;
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    BASE = 1e7;
    LOG_BASE = 7;
    MAX_SAFE_INTEGER = 9007199254740991;
    MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE);
    P = {};
    P.absoluteValue = P.abs = function() {
      var x = new this.constructor(this);
      if (x.s)
        x.s = 1;
      return x;
    };
    P.comparedTo = P.cmp = function(y) {
      var i, j, xdL, ydL, x = this;
      y = new x.constructor(y);
      if (x.s !== y.s)
        return x.s || -y.s;
      if (x.e !== y.e)
        return x.e > y.e ^ x.s < 0 ? 1 : -1;
      xdL = x.d.length;
      ydL = y.d.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (x.d[i] !== y.d[i])
          return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
    };
    P.decimalPlaces = P.dp = function() {
      var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE;
      w = x.d[w];
      if (w)
        for (; w % 10 == 0; w /= 10)
          dp--;
      return dp < 0 ? 0 : dp;
    };
    P.dividedBy = P.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P.dividedToIntegerBy = P.idiv = function(y) {
      var x = this, Ctor = x.constructor;
      return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
    };
    P.equals = P.eq = function(y) {
      return !this.cmp(y);
    };
    P.exponent = function() {
      return getBase10Exponent(this);
    };
    P.greaterThan = P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y) {
      return this.cmp(y) >= 0;
    };
    P.isInteger = P.isint = function() {
      return this.e > this.d.length - 2;
    };
    P.isNegative = P.isneg = function() {
      return this.s < 0;
    };
    P.isPositive = P.ispos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return this.s === 0;
    };
    P.lessThan = P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.logarithm = P.log = function(base) {
      var r, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
      if (base === void 0) {
        base = new Ctor(10);
      } else {
        base = new Ctor(base);
        if (base.s < 1 || base.eq(ONE))
          throw Error(decimalError + "NaN");
      }
      if (x.s < 1)
        throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
      if (x.eq(ONE))
        return new Ctor(0);
      external = false;
      r = divide(ln(x, wpr), ln(base, wpr), wpr);
      external = true;
      return round(r, pr);
    };
    P.minus = P.sub = function(y) {
      var x = this;
      y = new x.constructor(y);
      return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
    };
    P.modulo = P.mod = function(y) {
      var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
      y = new Ctor(y);
      if (!y.s)
        throw Error(decimalError + "NaN");
      if (!x.s)
        return round(new Ctor(x), pr);
      external = false;
      q = divide(x, y, 0, 1).times(y);
      external = true;
      return x.minus(q);
    };
    P.naturalExponential = P.exp = function() {
      return exp(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return ln(this);
    };
    P.negated = P.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s || 0;
      return x;
    };
    P.plus = P.add = function(y) {
      var x = this;
      y = new x.constructor(y);
      return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
    };
    P.precision = P.sd = function(z) {
      var e, sd, w, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
        throw Error(invalidArgument + z);
      e = getBase10Exponent(x) + 1;
      w = x.d.length - 1;
      sd = w * LOG_BASE + 1;
      w = x.d[w];
      if (w) {
        for (; w % 10 == 0; w /= 10)
          sd--;
        for (w = x.d[0]; w >= 10; w /= 10)
          sd++;
      }
      return z && e > sd ? e : sd;
    };
    P.squareRoot = P.sqrt = function() {
      var e, n, pr, r, s, t, wpr, x = this, Ctor = x.constructor;
      if (x.s < 1) {
        if (!x.s)
          return new Ctor(0);
        throw Error(decimalError + "NaN");
      }
      e = getBase10Exponent(x);
      external = false;
      s = Math.sqrt(+x);
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(x.d);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }
      pr = Ctor.precision;
      s = wpr = pr + 3;
      for (; ; ) {
        t = r;
        r = t.plus(divide(x, t, wpr + 2)).times(0.5);
        if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
          n = n.slice(wpr - 3, wpr + 1);
          if (s == wpr && n == "4999") {
            round(t, pr + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          } else if (n != "9999") {
            break;
          }
          wpr += 4;
        }
      }
      external = true;
      return round(r, pr);
    };
    P.times = P.mul = function(y) {
      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      if (!x.s || !y.s)
        return new Ctor(0);
      y.s *= x.s;
      e = x.e + y.e;
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--; )
        r.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }
        r[k] = (r[k] + carry) % BASE | 0;
      }
      for (; !r[--rL]; )
        r.pop();
      if (carry)
        ++e;
      else
        r.shift();
      y.d = r;
      y.e = e;
      return external ? round(y, Ctor.precision) : y;
    };
    P.toDecimalPlaces = P.todp = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0)
        return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      return round(x, dp + getBase10Exponent(x) + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = toString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = round(new Ctor(x), dp + 1, rm);
        str = toString(x, true, dp + 1);
      }
      return str;
    };
    P.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0)
        return toString(x);
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
      str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);
      return x.isneg() && !x.isZero() ? "-" + str : str;
    };
    P.toInteger = P.toint = function() {
      var x = this, Ctor = x.constructor;
      return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
    };
    P.toNumber = function() {
      return +this;
    };
    P.toPower = P.pow = function(y) {
      var e, k, pr, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
      if (!y.s)
        return new Ctor(ONE);
      x = new Ctor(x);
      if (!x.s) {
        if (y.s < 1)
          throw Error(decimalError + "Infinity");
        return x;
      }
      if (x.eq(ONE))
        return x;
      pr = Ctor.precision;
      if (y.eq(ONE))
        return round(x, pr);
      e = y.e;
      k = y.d.length - 1;
      yIsInt = e >= k;
      sign = x.s;
      if (!yIsInt) {
        if (sign < 0)
          throw Error(decimalError + "NaN");
      } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = new Ctor(ONE);
        e = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (k % 2) {
            r = r.times(x);
            truncate(r.d, e);
          }
          k = mathfloor(k / 2);
          if (k === 0)
            break;
          x = x.times(x);
          truncate(x.d, e);
        }
        external = true;
        return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
      }
      sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
      x.s = 1;
      external = false;
      r = y.times(ln(x, pr + guard));
      external = true;
      r = exp(r);
      r.s = sign;
      return r;
    };
    P.toPrecision = function(sd, rm) {
      var e, str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        e = getBase10Exponent(x);
        str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = round(new Ctor(x), sd, rm);
        e = getBase10Exponent(x);
        str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
      }
      return str;
    };
    P.toSignificantDigits = P.tosd = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      }
      return round(new Ctor(x), sd, rm);
    };
    P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
      var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
      return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
    };
    divide = /* @__PURE__ */ function() {
      function multiplyInteger(x, k) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % BASE | 0;
          carry = temp / BASE | 0;
        }
        if (carry)
          x.unshift(carry);
        return x;
      }
      function compare(a, b, aL, bL) {
        var i, r;
        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r;
      }
      function subtract2(a, b, aL) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * BASE + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; )
          a.shift();
      }
      return function(x, y, pr, dp) {
        var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!x.s)
          return new Ctor(x);
        if (!y.s)
          throw Error(decimalError + "Division by zero");
        e = x.e - y.e;
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); )
          ++i;
        if (yd[i] > (xd[i] || 0))
          --e;
        if (pr == null) {
          sd = pr = Ctor.precision;
        } else if (dp) {
          sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0)
          return new Ctor(0);
        sd = sd / LOG_BASE + 2 | 0;
        i = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i < xL || k) && sd--; i++) {
            t = k * BASE + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }
        } else {
          k = BASE / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k);
            xd = multiplyInteger(xd, k);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; )
            rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= BASE / 2)
            ++yd0;
          do {
            k = 0;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * BASE + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= BASE)
                  k = BASE - 1;
                prod = multiplyInteger(yd, k);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract2(prod, yL < prodL ? yz : yd, prodL);
                }
              } else {
                if (k == 0)
                  cmp = k = 1;
                prod = yd.slice();
              }
              prodL = prod.length;
              if (prodL < remL)
                prod.unshift(0);
              subtract2(rem, prod, remL);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract2(rem, yL < remL ? yz : yd, remL);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        }
        if (!qd[0])
          qd.shift();
        q.e = e;
        return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
      };
    }();
    Decimal = clone(defaults);
    ONE = new Decimal(1);
    decimal_default = Decimal;
  }
});

// node_modules/big.js/big.mjs
function _Big_() {
  function Big3(n) {
    var x = this;
    if (!(x instanceof Big3))
      return n === UNDEFINED ? _Big_() : new Big3(n);
    if (n instanceof Big3) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }
    x.constructor = Big3;
  }
  Big3.prototype = P2;
  Big3.DP = DP;
  Big3.RM = RM;
  Big3.NE = NE;
  Big3.PE = PE;
  Big3.version = "5.2.2";
  return Big3;
}
function parse(x, n) {
  var e, i, nl;
  if (n === 0 && 1 / n < 0)
    n = "-0";
  else if (!NUMERIC.test(n += ""))
    throw Error(INVALID + "number");
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1)
    n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; )
    ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; )
      ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; )
      x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round2(x, dp, rm, more) {
  var xc = x.c, i = x.e + dp + 1;
  if (i < xc.length) {
    if (rm === 1) {
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0)
        throw Error(INVALID_RM);
    }
    if (i < 1) {
      xc.length = 1;
      if (more) {
        x.e = -dp;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else {
      xc.length = i--;
      if (more) {
        for (; ++xc[i] > 9; ) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }
      for (i = xc.length; !xc[--i]; )
        xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x;
}
function stringify(x, id, n, k) {
  var e, s, Big3 = x.constructor, z = !x.c[0];
  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
    }
    x = new Big3(x);
    n = k - x.e;
    if (x.c.length > ++k)
      round2(x, n, Big3.RM);
    if (id == 2)
      k = x.e + n + 1;
    for (; x.c.length < k; )
      x.c.push(0);
  }
  e = x.e;
  s = x.c.join("");
  n = s.length;
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big3.NE || e >= Big3.PE)) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; )
      s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n)
      for (e -= n; e--; )
        s += "0";
    else if (e < n)
      s = s.slice(0, e) + "." + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && (!z || id == 4) ? "-" + s : s;
}
var DP, RM, MAX_DP, MAX_POWER, NE, PE, NAME, INVALID, INVALID_DP, INVALID_RM, DIV_BY_ZERO, P2, UNDEFINED, NUMERIC, Big, big_default;
var init_big = __esm({
  "node_modules/big.js/big.mjs"() {
    DP = 20;
    RM = 1;
    MAX_DP = 1e6;
    MAX_POWER = 1e6;
    NE = -7;
    PE = 21;
    NAME = "[big.js] ";
    INVALID = NAME + "Invalid ";
    INVALID_DP = INVALID + "decimal places";
    INVALID_RM = INVALID + "rounding mode";
    DIV_BY_ZERO = NAME + "Division by zero";
    P2 = {};
    UNDEFINED = void 0;
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    P2.abs = function() {
      var x = new this.constructor(this);
      x.s = 1;
      return x;
    };
    P2.cmp = function(y) {
      var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!xc[0] || !yc[0])
        return !xc[0] ? !yc[0] ? 0 : -j : i;
      if (i != j)
        return i;
      isneg = i < 0;
      if (k != l)
        return k > l ^ isneg ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = -1; ++i < j; ) {
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ isneg ? 1 : -1;
      }
      return k == l ? 0 : k > l ^ isneg ? 1 : -1;
    };
    P2.div = function(y) {
      var x = this, Big3 = x.constructor, a = x.c, b = (y = new Big3(y)).c, k = x.s == y.s ? 1 : -1, dp = Big3.DP;
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
        throw Error(INVALID_DP);
      if (!b[0])
        throw Error(DIV_BY_ZERO);
      if (!a[0])
        return new Big3(k * 0);
      var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
      q.s = k;
      k = d < 0 ? 0 : d;
      bz.unshift(0);
      for (; rl++ < bl; )
        r.push(0);
      do {
        for (n = 0; n < 10; n++) {
          if (bl != (rl = r.length)) {
            cmp = bl > rl ? 1 : -1;
          } else {
            for (ri = -1, cmp = 0; ++ri < bl; ) {
              if (b[ri] != r[ri]) {
                cmp = b[ri] > r[ri] ? 1 : -1;
                break;
              }
            }
          }
          if (cmp < 0) {
            for (bt = rl == bl ? b : bz; rl; ) {
              if (r[--rl] < bt[rl]) {
                ri = rl;
                for (; ri && !r[--ri]; )
                  r[ri] = 9;
                --r[ri];
                r[rl] += 10;
              }
              r[rl] -= bt[rl];
            }
            for (; !r[0]; )
              r.shift();
          } else {
            break;
          }
        }
        qc[qi++] = cmp ? n : ++n;
        if (r[0] && cmp)
          r[rl] = a[ai] || 0;
        else
          r = [a[ai]];
      } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
      if (!qc[0] && qi != 1) {
        qc.shift();
        q.e--;
      }
      if (qi > d)
        round2(q, dp, Big3.RM, r[0] !== UNDEFINED);
      return q;
    };
    P2.eq = function(y) {
      return !this.cmp(y);
    };
    P2.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P2.gte = function(y) {
      return this.cmp(y) > -1;
    };
    P2.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P2.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P2.minus = P2.sub = function(y) {
      var i, j, t, xlty, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new Big3(xc[0] ? x : 0);
      }
      if (a = xe - ye) {
        if (xlty = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();
        for (b = a; b--; )
          t.push(0);
        t.reverse();
      } else {
        j = ((xlty = xc.length < yc.length) ? xc : yc).length;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xlty = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xlty) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }
      if ((b = (j = yc.length) - (i = xc.length)) > 0)
        for (; b--; )
          xc[i++] = 0;
      for (b = i; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; )
            xc[i] = 9;
          --xc[i];
          xc[j] += 10;
        }
        xc[j] -= yc[j];
      }
      for (; xc[--b] === 0; )
        xc.pop();
      for (; xc[0] === 0; ) {
        xc.shift();
        --ye;
      }
      if (!xc[0]) {
        y.s = 1;
        xc = [ye = 0];
      }
      y.c = xc;
      y.e = ye;
      return y;
    };
    P2.mod = function(y) {
      var ygtx, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
      if (!y.c[0])
        throw Error(DIV_BY_ZERO);
      x.s = y.s = 1;
      ygtx = y.cmp(x) == 1;
      x.s = a;
      y.s = b;
      if (ygtx)
        return new Big3(x);
      a = Big3.DP;
      b = Big3.RM;
      Big3.DP = Big3.RM = 0;
      x = x.div(y);
      Big3.DP = a;
      Big3.RM = b;
      return this.minus(x.times(y));
    };
    P2.plus = P2.add = function(y) {
      var t, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new Big3(xc[0] ? x : a * 0);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; )
          t.push(0);
        t.reverse();
      }
      if (xc.length - yc.length < 0) {
        t = yc;
        yc = xc;
        xc = t;
      }
      a = yc.length;
      for (b = 0; a; xc[a] %= 10)
        b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
      if (b) {
        xc.unshift(b);
        ++ye;
      }
      for (a = xc.length; xc[--a] === 0; )
        xc.pop();
      y.c = xc;
      y.e = ye;
      return y;
    };
    P2.pow = function(n) {
      var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
      if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER)
        throw Error(INVALID + "exponent");
      if (isneg)
        n = -n;
      for (; ; ) {
        if (n & 1)
          y = y.times(x);
        n >>= 1;
        if (!n)
          break;
        x = x.times(x);
      }
      return isneg ? one.div(y) : y;
    };
    P2.round = function(dp, rm) {
      var Big3 = this.constructor;
      if (dp === UNDEFINED)
        dp = 0;
      else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
        throw Error(INVALID_DP);
      return round2(new Big3(this), dp, rm === UNDEFINED ? Big3.RM : rm);
    };
    P2.sqrt = function() {
      var r, c, t, x = this, Big3 = x.constructor, s = x.s, e = x.e, half = new Big3(0.5);
      if (!x.c[0])
        return new Big3(x);
      if (s < 0)
        throw Error(NAME + "No square root");
      s = Math.sqrt(x + "");
      if (s === 0 || s === 1 / 0) {
        c = x.c.join("");
        if (!(c.length + e & 1))
          c += "0";
        s = Math.sqrt(c);
        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
        r = new Big3((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
      } else {
        r = new Big3(s);
      }
      e = r.e + (Big3.DP += 4);
      do {
        t = r;
        r = half.times(t.plus(x.div(t)));
      } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
      return round2(r, Big3.DP -= 4, Big3.RM);
    };
    P2.times = P2.mul = function(y) {
      var c, x = this, Big3 = x.constructor, xc = x.c, yc = (y = new Big3(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
      y.s = x.s == y.s ? 1 : -1;
      if (!xc[0] || !yc[0])
        return new Big3(y.s * 0);
      y.e = i + j;
      if (a < b) {
        c = xc;
        xc = yc;
        yc = c;
        j = a;
        a = b;
        b = j;
      }
      for (c = new Array(j = a + b); j--; )
        c[j] = 0;
      for (i = b; i--; ) {
        b = 0;
        for (j = a + i; j > i; ) {
          b = c[j] + yc[i] * xc[j - i - 1] + b;
          c[j--] = b % 10;
          b = b / 10 | 0;
        }
        c[j] = (c[j] + b) % 10;
      }
      if (b)
        ++y.e;
      else
        c.shift();
      for (i = c.length; !c[--i]; )
        c.pop();
      y.c = c;
      return y;
    };
    P2.toExponential = function(dp) {
      return stringify(this, 1, dp, dp);
    };
    P2.toFixed = function(dp) {
      return stringify(this, 2, dp, this.e + dp);
    };
    P2.toPrecision = function(sd) {
      return stringify(this, 3, sd, sd - 1);
    };
    P2.toString = function() {
      return stringify(this);
    };
    P2.valueOf = P2.toJSON = function() {
      return stringify(this, 4);
    };
    Big = _Big_();
    big_default = Big;
  }
});

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports, module) {
    function toFormat2(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat3(dp, rm, fmt) {
        if (!this.e && this.e !== 0)
          return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u)
              dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u)
            gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u)
                gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u)
                sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1)
              intp += gsep + intd.substr(i, g1);
            if (g2 > 0)
              intp += gsep + intd.slice(i);
            if (this.s < 0)
              intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u)
              fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u)
                  fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module !== "undefined" && module.exports)
      module.exports = toFormat2;
  }
});

// node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js
var sdk_core_esm_exports = {};
__export(sdk_core_esm_exports, {
  ARGENT_WALLET_DETECTOR_ADDRESS: () => ARGENT_WALLET_DETECTOR_ADDRESS,
  CHAIN_TO_ADDRESSES_MAP: () => CHAIN_TO_ADDRESSES_MAP,
  ChainId: () => ChainId,
  CurrencyAmount: () => CurrencyAmount,
  ENS_REGISTRAR_ADDRESSES: () => ENS_REGISTRAR_ADDRESSES,
  Ether: () => Ether,
  Fraction: () => Fraction,
  GOVERNANCE_ALPHA_V0_ADDRESSES: () => GOVERNANCE_ALPHA_V0_ADDRESSES,
  GOVERNANCE_ALPHA_V1_ADDRESSES: () => GOVERNANCE_ALPHA_V1_ADDRESSES,
  GOVERNANCE_BRAVO_ADDRESSES: () => GOVERNANCE_BRAVO_ADDRESSES,
  MERKLE_DISTRIBUTOR_ADDRESS: () => MERKLE_DISTRIBUTOR_ADDRESS,
  MIXED_ROUTE_QUOTER_V1_ADDRESSES: () => MIXED_ROUTE_QUOTER_V1_ADDRESSES,
  MULTICALL_ADDRESSES: () => MULTICALL_ADDRESSES,
  MaxUint256: () => MaxUint256,
  NONFUNGIBLE_POSITION_MANAGER_ADDRESSES: () => NONFUNGIBLE_POSITION_MANAGER_ADDRESSES,
  NativeCurrency: () => NativeCurrency,
  NativeCurrencyName: () => NativeCurrencyName,
  Percent: () => Percent,
  Price: () => Price,
  QUOTER_ADDRESSES: () => QUOTER_ADDRESSES,
  Rounding: () => Rounding,
  SOCKS_CONTROLLER_ADDRESSES: () => SOCKS_CONTROLLER_ADDRESSES,
  SUPPORTED_CHAINS: () => SUPPORTED_CHAINS,
  SWAP_ROUTER_02_ADDRESSES: () => SWAP_ROUTER_02_ADDRESSES,
  TICK_LENS_ADDRESSES: () => TICK_LENS_ADDRESSES,
  TIMELOCK_ADDRESSES: () => TIMELOCK_ADDRESSES,
  Token: () => Token,
  TradeType: () => TradeType,
  UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS: () => UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS,
  UNI_ADDRESSES: () => UNI_ADDRESSES,
  V2_FACTORY_ADDRESS: () => V2_FACTORY_ADDRESS,
  V2_FACTORY_ADDRESSES: () => V2_FACTORY_ADDRESSES,
  V2_ROUTER_ADDRESS: () => V2_ROUTER_ADDRESS,
  V2_ROUTER_ADDRESSES: () => V2_ROUTER_ADDRESSES,
  V3_CORE_FACTORY_ADDRESSES: () => V3_CORE_FACTORY_ADDRESSES,
  V3_MIGRATOR_ADDRESSES: () => V3_MIGRATOR_ADDRESSES,
  WETH9: () => WETH9,
  computePriceImpact: () => computePriceImpact,
  sortedInsert: () => sortedInsert,
  sqrt: () => sqrt,
  validateAndParseAddress: () => validateAndParseAddress
});
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function constructSameAddressMap(address, additionalNetworks) {
  if (additionalNetworks === void 0) {
    additionalNetworks = [];
  }
  return DEFAULT_NETWORKS.concat(additionalNetworks).reduce(function(memo, chainId) {
    memo[chainId] = address;
    return memo;
  }, {});
}
function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
}
function validateAndParseAddress(address) {
  try {
    return getAddress(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
function checkValidAddress(address) {
  if (startsWith0xLen42HexRegex.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
function computePriceImpact(midPrice, inputAmount, outputAmount) {
  var quotedOutputAmount = midPrice.quote(inputAmount);
  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);
  return new Percent(priceImpact.numerator, priceImpact.denominator);
}
function sortedInsert(items, add2, maxSize, comparator) {
  !(maxSize > 0) ? true ? invariant(false, "MAX_SIZE_ZERO") : invariant(false) : void 0;
  !(items.length <= maxSize) ? true ? invariant(false, "ITEMS_SIZE") : invariant(false) : void 0;
  if (items.length === 0) {
    items.push(add2);
    return null;
  } else {
    var isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add2) <= 0) {
      return add2;
    }
    var lo = 0, hi = items.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (comparator(items[mid], add2) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add2);
    return isFull ? items.pop() : null;
  }
}
function sqrt(value) {
  !jsbi_default.greaterThanOrEqual(value, ZERO) ? true ? invariant(false, "NEGATIVE") : invariant(false) : void 0;
  if (jsbi_default.lessThan(value, MAX_SAFE_INTEGER2)) {
    return jsbi_default.BigInt(Math.floor(Math.sqrt(jsbi_default.toNumber(value))));
  }
  var z;
  var x;
  z = value;
  x = jsbi_default.add(jsbi_default.divide(value, TWO), ONE2);
  while (jsbi_default.lessThan(x, z)) {
    z = x;
    x = jsbi_default.divide(jsbi_default.add(jsbi_default.divide(value, x), x), TWO);
  }
  return z;
}
var import_toformat, ChainId, SUPPORTED_CHAINS, NativeCurrencyName, _V2_FACTORY_ADDRESSES, _V2_ROUTER_ADDRESSES, _CHAIN_TO_ADDRESSES_M, _GOVERNANCE_ALPHA_V1_, _GOVERNANCE_BRAVO_ADD, _MERKLE_DISTRIBUTOR_A, _ARGENT_WALLET_DETECT, _SOCKS_CONTROLLER_ADD, DEFAULT_NETWORKS, UNI_ADDRESSES, UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS, V2_FACTORY_ADDRESS, V2_FACTORY_ADDRESSES, V2_ROUTER_ADDRESS, V2_ROUTER_ADDRESSES, DEFAULT_ADDRESSES, MAINNET_ADDRESSES, GOERLI_ADDRESSES, OPTIMISM_ADDRESSES, ARBITRUM_ONE_ADDRESSES, POLYGON_ADDRESSES, CELO_ADDRESSES, BNB_ADDRESSES, OPTIMISM_GOERLI_ADDRESSES, OPTIMISM_SEPOLIA_ADDRESSES, ARBITRUM_GOERLI_ADDRESSES, ARBITRUM_SEPOLIA_ADDRESSES, SEPOLIA_ADDRESSES, AVALANCHE_ADDRESSES, BASE_ADDRESSES, BASE_GOERLI_ADDRESSES, ZORA_ADDRESSES, ZORA_SEPOLIA_ADDRESSES, ROOTSTOCK_ADDRESSES, BLAST_ADDRESSES, CHAIN_TO_ADDRESSES_MAP, V3_CORE_FACTORY_ADDRESSES, V3_MIGRATOR_ADDRESSES, MULTICALL_ADDRESSES, GOVERNANCE_ALPHA_V0_ADDRESSES, GOVERNANCE_ALPHA_V1_ADDRESSES, GOVERNANCE_BRAVO_ADDRESSES, TIMELOCK_ADDRESSES, MERKLE_DISTRIBUTOR_ADDRESS, ARGENT_WALLET_DETECTOR_ADDRESS, QUOTER_ADDRESSES, NONFUNGIBLE_POSITION_MANAGER_ADDRESSES, ENS_REGISTRAR_ADDRESSES, SOCKS_CONTROLLER_ADDRESSES, TICK_LENS_ADDRESSES, MIXED_ROUTE_QUOTER_V1_ADDRESSES, SWAP_ROUTER_02_ADDRESSES, TradeType, Rounding, MaxUint256, _toSignificantRoundin, _toFixedRounding, Decimal2, Big2, toSignificantRounding, toFixedRounding, Fraction, Big$1, CurrencyAmount, ONE_HUNDRED, Percent, Price, BaseCurrency, NativeCurrency, startsWith0xLen42HexRegex, Token, _WETH, WETH9, Ether, MAX_SAFE_INTEGER2, ZERO, ONE2, TWO;
var init_sdk_core_esm = __esm({
  "node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js"() {
    init_jsbi();
    init_tiny_invariant();
    init_decimal();
    init_big();
    import_toformat = __toESM(require_toFormat());
    init_lib();
    init_lib2();
    (function(ChainId2) {
      ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
      ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
      ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
      ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
      ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
      ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
      ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
      ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
      ChainId2[ChainId2["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
      ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
      ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
      ChainId2[ChainId2["CELO"] = 42220] = "CELO";
      ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
      ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
      ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
      ChainId2[ChainId2["BNB"] = 56] = "BNB";
      ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
      ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
      ChainId2[ChainId2["BASE"] = 8453] = "BASE";
      ChainId2[ChainId2["ZORA"] = 7777777] = "ZORA";
      ChainId2[ChainId2["ZORA_SEPOLIA"] = 999999999] = "ZORA_SEPOLIA";
      ChainId2[ChainId2["ROOTSTOCK"] = 30] = "ROOTSTOCK";
      ChainId2[ChainId2["BLAST"] = 81457] = "BLAST";
    })(ChainId || (ChainId = {}));
    SUPPORTED_CHAINS = [ChainId.MAINNET, ChainId.OPTIMISM, ChainId.OPTIMISM_GOERLI, ChainId.OPTIMISM_SEPOLIA, ChainId.ARBITRUM_ONE, ChainId.ARBITRUM_GOERLI, ChainId.ARBITRUM_SEPOLIA, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.GOERLI, ChainId.SEPOLIA, ChainId.CELO_ALFAJORES, ChainId.CELO, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE, ChainId.BASE_GOERLI, ChainId.ZORA, ChainId.ZORA_SEPOLIA, ChainId.ROOTSTOCK, ChainId.BLAST];
    (function(NativeCurrencyName2) {
      NativeCurrencyName2["ETHER"] = "ETH";
      NativeCurrencyName2["MATIC"] = "MATIC";
      NativeCurrencyName2["CELO"] = "CELO";
      NativeCurrencyName2["GNOSIS"] = "XDAI";
      NativeCurrencyName2["MOONBEAM"] = "GLMR";
      NativeCurrencyName2["BNB"] = "BNB";
      NativeCurrencyName2["AVAX"] = "AVAX";
      NativeCurrencyName2["ROOTSTOCK"] = "RBTC";
    })(NativeCurrencyName || (NativeCurrencyName = {}));
    DEFAULT_NETWORKS = [ChainId.MAINNET, ChainId.GOERLI, ChainId.SEPOLIA];
    UNI_ADDRESSES = constructSameAddressMap("0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", [ChainId.OPTIMISM, ChainId.ARBITRUM_ONE, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.SEPOLIA]);
    UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS = "0x8B799381ac40b838BBA4131ffB26197C432AFe78";
    V2_FACTORY_ADDRESS = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
    V2_FACTORY_ADDRESSES = (_V2_FACTORY_ADDRESSES = {}, _V2_FACTORY_ADDRESSES[ChainId.MAINNET] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.GOERLI] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.SEPOLIA] = "0xB7f907f7A9eBC822a80BD25E224be42Ce0A698A0", _V2_FACTORY_ADDRESSES[ChainId.OPTIMISM] = "0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf", _V2_FACTORY_ADDRESSES[ChainId.ARBITRUM_ONE] = "0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9", _V2_FACTORY_ADDRESSES[ChainId.AVALANCHE] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", _V2_FACTORY_ADDRESSES[ChainId.BASE] = "0x8909dc15e40173ff4699343b6eb8132c65e18ec6", _V2_FACTORY_ADDRESSES[ChainId.BNB] = "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6", _V2_FACTORY_ADDRESSES[ChainId.POLYGON] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", _V2_FACTORY_ADDRESSES[ChainId.CELO] = "0x79a530c8e2fA8748B7B40dd3629C0520c2cCf03f", _V2_FACTORY_ADDRESSES[ChainId.BLAST] = "0x5C346464d33F90bABaf70dB6388507CC889C1070", _V2_FACTORY_ADDRESSES);
    V2_ROUTER_ADDRESS = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
    V2_ROUTER_ADDRESSES = (_V2_ROUTER_ADDRESSES = {}, _V2_ROUTER_ADDRESSES[ChainId.MAINNET] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", _V2_ROUTER_ADDRESSES[ChainId.GOERLI] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", _V2_ROUTER_ADDRESSES[ChainId.ARBITRUM_ONE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.OPTIMISM] = "0x4a7b5da61326a6379179b40d00f57e5bbdc962c2", _V2_ROUTER_ADDRESSES[ChainId.BASE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.AVALANCHE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.BNB] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.POLYGON] = "0xedf6066a2b290c185783862c7f4776a2c8077ad1", _V2_ROUTER_ADDRESSES[ChainId.BLAST] = "0xBB66Eb1c5e875933D44DAe661dbD80e5D9B03035", _V2_ROUTER_ADDRESSES);
    DEFAULT_ADDRESSES = {
      v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
      multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
      quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
      v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
      nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
    };
    MAINNET_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
      v1MixedRouteQuoterAddress: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E"
    });
    GOERLI_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
      v1MixedRouteQuoterAddress: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
    });
    OPTIMISM_ADDRESSES = DEFAULT_ADDRESSES;
    ARBITRUM_ONE_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
      multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
      tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573"
    });
    POLYGON_ADDRESSES = DEFAULT_ADDRESSES;
    CELO_ADDRESSES = {
      v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
      multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
      quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
      v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
      nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
      tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
    };
    BNB_ADDRESSES = {
      v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
      multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
      quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
      v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
      nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
      tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
      swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2"
    };
    OPTIMISM_GOERLI_ADDRESSES = {
      v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
      multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
      quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
      v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
      nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
      tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
    };
    OPTIMISM_SEPOLIA_ADDRESSES = {
      v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
      multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
      quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
      v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
      nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
      tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5",
      swapRouter02Address: "0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4"
    };
    ARBITRUM_GOERLI_ADDRESSES = {
      v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
      multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
      quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
      v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
      nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
      tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
    };
    ARBITRUM_SEPOLIA_ADDRESSES = {
      v3CoreFactoryAddress: "0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e",
      multicallAddress: "0x2B718b475e385eD29F56775a66aAB1F5cC6B2A0A",
      quoterAddress: "0x2779a0CC1c3e0E44D2542EC3e79e3864Ae93Ef0B",
      v3MigratorAddress: "0x398f43ef2c67B941147157DA1c5a868E906E043D",
      nonfungiblePositionManagerAddress: "0x6b2937Bde17889EDCf8fbD8dE31C3C2a70Bc4d65",
      tickLensAddress: "0x0fd18587734e5C2dcE2dccDcC7DD1EC89ba557d9",
      swapRouter02Address: "0x101F443B4d1b059569D643917553c771E1b9663E"
    };
    SEPOLIA_ADDRESSES = {
      v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
      multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
      quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
      v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
      nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
      tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07",
      swapRouter02Address: "0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E"
    };
    AVALANCHE_ADDRESSES = {
      v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
      multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
      quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
      v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
      nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
      tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
      swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE"
    };
    BASE_ADDRESSES = {
      v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
      multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
      quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
      v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
      nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
      tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
      swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481"
    };
    BASE_GOERLI_ADDRESSES = {
      v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
      multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
      quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
      v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
      nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
      tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
      swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
    };
    ZORA_ADDRESSES = {
      v3CoreFactoryAddress: "0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb",
      multicallAddress: "0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15",
      quoterAddress: "0x11867e1b3348F3ce4FcC170BC5af3d23E07E64Df",
      v3MigratorAddress: "0x048352d8dCF13686982C799da63fA6426a9D0b60",
      nonfungiblePositionManagerAddress: "0xbC91e8DfA3fF18De43853372A3d7dfe585137D78",
      tickLensAddress: "0x209AAda09D74Ad3B8D0E92910Eaf85D2357e3044",
      swapRouter02Address: "0x7De04c96BE5159c3b5CeffC82aa176dc81281557"
    };
    ZORA_SEPOLIA_ADDRESSES = {
      v3CoreFactoryAddress: "0x4324A677D74764f46f33ED447964252441aA8Db6",
      multicallAddress: "0xA1E7e3A69671C4494EC59Dbd442de930a93F911A",
      quoterAddress: "0xC195976fEF0985886E37036E2DF62bF371E12Df0",
      v3MigratorAddress: "0x65ef259b31bf1d977c37e9434658694267674897",
      nonfungiblePositionManagerAddress: "0xB8458EaAe43292e3c1F7994EFd016bd653d23c20",
      tickLensAddress: "0x23C0F71877a1Fc4e20A78018f9831365c85f3064"
    };
    ROOTSTOCK_ADDRESSES = {
      v3CoreFactoryAddress: "0xaF37EC98A00FD63689CF3060BF3B6784E00caD82",
      multicallAddress: "0x996a9858cDfa45Ad68E47c9A30a7201E29c6a386",
      quoterAddress: "0xb51727c996C68E60F598A923a5006853cd2fEB31",
      v3MigratorAddress: "0x16678977CA4ec3DAD5efc7b15780295FE5f56162",
      nonfungiblePositionManagerAddress: "0x9d9386c042F194B460Ec424a1e57ACDE25f5C4b1",
      tickLensAddress: "0x55B9dF5bF68ADe972191a91980459f48ecA16afC",
      swapRouter02Address: "0x0B14ff67f0014046b4b99057Aec4509640b3947A"
    };
    BLAST_ADDRESSES = {
      v3CoreFactoryAddress: "0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd",
      multicallAddress: "0xdC7f370de7631cE9e2c2e1DCDA6B3B5744Cf4705",
      quoterAddress: "0x6Cdcd65e03c1CEc3730AeeCd45bc140D57A25C77",
      v3MigratorAddress: "0x15CA7043CD84C5D21Ae76Ba0A1A967d42c40ecE0",
      nonfungiblePositionManagerAddress: "0xB218e4f7cF0533d4696fDfC419A0023D33345F28",
      tickLensAddress: "0x2E95185bCdD928a3e984B7e2D6560Ab1b17d7274",
      swapRouter02Address: "0x549FEB8c9bd4c12Ad2AB27022dA12492aC452B66"
    };
    CHAIN_TO_ADDRESSES_MAP = (_CHAIN_TO_ADDRESSES_M = {}, _CHAIN_TO_ADDRESSES_M[ChainId.MAINNET] = MAINNET_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM] = OPTIMISM_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON_MUMBAI] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.GOERLI] = GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO_ALFAJORES] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BNB] = BNB_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_SEPOLIA] = ARBITRUM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.SEPOLIA] = SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.AVALANCHE] = AVALANCHE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE] = BASE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE_GOERLI] = BASE_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ZORA] = ZORA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ZORA_SEPOLIA] = ZORA_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ROOTSTOCK] = ROOTSTOCK_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BLAST] = BLAST_ADDRESSES, _CHAIN_TO_ADDRESSES_M);
    V3_CORE_FACTORY_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].v3CoreFactoryAddress;
      return memo;
    }, {}));
    V3_MIGRATOR_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      var v3MigratorAddress = CHAIN_TO_ADDRESSES_MAP[chainId].v3MigratorAddress;
      if (v3MigratorAddress) {
        memo[chainId] = v3MigratorAddress;
      }
      return memo;
    }, {}));
    MULTICALL_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].multicallAddress;
      return memo;
    }, {}));
    GOVERNANCE_ALPHA_V0_ADDRESSES = constructSameAddressMap("0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F");
    GOVERNANCE_ALPHA_V1_ADDRESSES = (_GOVERNANCE_ALPHA_V1_ = {}, _GOVERNANCE_ALPHA_V1_[ChainId.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6", _GOVERNANCE_ALPHA_V1_);
    GOVERNANCE_BRAVO_ADDRESSES = (_GOVERNANCE_BRAVO_ADD = {}, _GOVERNANCE_BRAVO_ADD[ChainId.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3", _GOVERNANCE_BRAVO_ADD);
    TIMELOCK_ADDRESSES = constructSameAddressMap("0x1a9C8182C09F50C8318d769245beA52c32BE35BC");
    MERKLE_DISTRIBUTOR_ADDRESS = (_MERKLE_DISTRIBUTOR_A = {}, _MERKLE_DISTRIBUTOR_A[ChainId.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e", _MERKLE_DISTRIBUTOR_A);
    ARGENT_WALLET_DETECTOR_ADDRESS = (_ARGENT_WALLET_DETECT = {}, _ARGENT_WALLET_DETECT[ChainId.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8", _ARGENT_WALLET_DETECT);
    QUOTER_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].quoterAddress;
      return memo;
    }, {}));
    NONFUNGIBLE_POSITION_MANAGER_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      var nonfungiblePositionManagerAddress = CHAIN_TO_ADDRESSES_MAP[chainId].nonfungiblePositionManagerAddress;
      if (nonfungiblePositionManagerAddress) {
        memo[chainId] = nonfungiblePositionManagerAddress;
      }
      return memo;
    }, {}));
    ENS_REGISTRAR_ADDRESSES = _extends({}, constructSameAddressMap("0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"));
    SOCKS_CONTROLLER_ADDRESSES = (_SOCKS_CONTROLLER_ADD = {}, _SOCKS_CONTROLLER_ADD[ChainId.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd", _SOCKS_CONTROLLER_ADD);
    TICK_LENS_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      var tickLensAddress = CHAIN_TO_ADDRESSES_MAP[chainId].tickLensAddress;
      if (tickLensAddress) {
        memo[chainId] = tickLensAddress;
      }
      return memo;
    }, {}));
    MIXED_ROUTE_QUOTER_V1_ADDRESSES = SUPPORTED_CHAINS.reduce(function(memo, chainId) {
      var v1MixedRouteQuoterAddress = CHAIN_TO_ADDRESSES_MAP[chainId].v1MixedRouteQuoterAddress;
      if (v1MixedRouteQuoterAddress) {
        memo[chainId] = v1MixedRouteQuoterAddress;
      }
      return memo;
    }, {});
    SWAP_ROUTER_02_ADDRESSES = function SWAP_ROUTER_02_ADDRESSES2(chainId) {
      if (SUPPORTED_CHAINS.includes(chainId)) {
        var _CHAIN_TO_ADDRESSES_M2;
        var id = chainId;
        return (_CHAIN_TO_ADDRESSES_M2 = CHAIN_TO_ADDRESSES_MAP[id].swapRouter02Address) != null ? _CHAIN_TO_ADDRESSES_M2 : "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
      }
      return "";
    };
    (function(TradeType2) {
      TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
      TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
    })(TradeType || (TradeType = {}));
    (function(Rounding2) {
      Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
      Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
      Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
    })(Rounding || (Rounding = {}));
    MaxUint256 = jsbi_default.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    Decimal2 = (0, import_toformat.default)(decimal_default);
    Big2 = (0, import_toformat.default)(big_default);
    toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal2.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal2.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal2.ROUND_UP, _toSignificantRoundin);
    toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
    Fraction = function() {
      function Fraction2(numerator, denominator) {
        if (denominator === void 0) {
          denominator = jsbi_default.BigInt(1);
        }
        this.numerator = jsbi_default.BigInt(numerator);
        this.denominator = jsbi_default.BigInt(denominator);
      }
      Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
        if (fractionish instanceof jsbi_default || typeof fractionish === "number" || typeof fractionish === "string")
          return new Fraction2(fractionish);
        if ("numerator" in fractionish && "denominator" in fractionish)
          return fractionish;
        throw new Error("Could not parse fraction");
      };
      var _proto = Fraction2.prototype;
      _proto.invert = function invert() {
        return new Fraction2(this.denominator, this.numerator);
      };
      _proto.add = function add2(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
          return new Fraction2(jsbi_default.add(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction2(jsbi_default.add(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.subtract = function subtract2(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
          return new Fraction2(jsbi_default.subtract(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction2(jsbi_default.subtract(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.lessThan = function lessThan(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        return jsbi_default.lessThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.equalTo = function equalTo(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        return jsbi_default.equal(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.greaterThan = function greaterThan(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        return jsbi_default.greaterThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.multiply = function multiply(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.numerator), jsbi_default.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.divide = function divide2(other) {
        var otherParsed = Fraction2.tryParseFraction(other);
        return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(this.denominator, otherParsed.numerator));
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        if (rounding === void 0) {
          rounding = Rounding.ROUND_HALF_UP;
        }
        !Number.isInteger(significantDigits) ? true ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
        !(significantDigits > 0) ? true ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
        Decimal2.set({
          precision: significantDigits + 1,
          rounding: toSignificantRounding[rounding]
        });
        var quotient = new Decimal2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
        return quotient.toFormat(quotient.decimalPlaces(), format);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        if (rounding === void 0) {
          rounding = Rounding.ROUND_HALF_UP;
        }
        !Number.isInteger(decimalPlaces) ? true ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
        !(decimalPlaces >= 0) ? true ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
        Big2.DP = decimalPlaces;
        Big2.RM = toFixedRounding[rounding];
        return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
      };
      _createClass(Fraction2, [{
        key: "quotient",
        get: function get() {
          return jsbi_default.divide(this.numerator, this.denominator);
        }
        // remainder after floor division
      }, {
        key: "remainder",
        get: function get() {
          return new Fraction2(jsbi_default.remainder(this.numerator, this.denominator), this.denominator);
        }
      }, {
        key: "asFraction",
        get: function get() {
          return new Fraction2(this.numerator, this.denominator);
        }
      }]);
      return Fraction2;
    }();
    Big$1 = (0, import_toformat.default)(big_default);
    CurrencyAmount = function(_Fraction) {
      _inheritsLoose(CurrencyAmount2, _Fraction);
      function CurrencyAmount2(currency, numerator, denominator) {
        var _this;
        _this = _Fraction.call(this, numerator, denominator) || this;
        !jsbi_default.lessThanOrEqual(_this.quotient, MaxUint256) ? true ? invariant(false, "AMOUNT") : invariant(false) : void 0;
        _this.currency = currency;
        _this.decimalScale = jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(currency.decimals));
        return _this;
      }
      CurrencyAmount2.fromRawAmount = function fromRawAmount(currency, rawAmount) {
        return new CurrencyAmount2(currency, rawAmount);
      };
      CurrencyAmount2.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
        return new CurrencyAmount2(currency, numerator, denominator);
      };
      var _proto = CurrencyAmount2.prototype;
      _proto.add = function add2(other) {
        !this.currency.equals(other.currency) ? true ? invariant(false, "CURRENCY") : invariant(false) : void 0;
        var added = _Fraction.prototype.add.call(this, other);
        return CurrencyAmount2.fromFractionalAmount(this.currency, added.numerator, added.denominator);
      };
      _proto.subtract = function subtract2(other) {
        !this.currency.equals(other.currency) ? true ? invariant(false, "CURRENCY") : invariant(false) : void 0;
        var subtracted = _Fraction.prototype.subtract.call(this, other);
        return CurrencyAmount2.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
      };
      _proto.multiply = function multiply(other) {
        var multiplied = _Fraction.prototype.multiply.call(this, other);
        return CurrencyAmount2.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
      };
      _proto.divide = function divide2(other) {
        var divided = _Fraction.prototype.divide.call(this, other);
        return CurrencyAmount2.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 6;
        }
        if (rounding === void 0) {
          rounding = Rounding.ROUND_DOWN;
        }
        return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = this.currency.decimals;
        }
        if (rounding === void 0) {
          rounding = Rounding.ROUND_DOWN;
        }
        !(decimalPlaces <= this.currency.decimals) ? true ? invariant(false, "DECIMALS") : invariant(false) : void 0;
        return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
      };
      _proto.toExact = function toExact(format) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        Big$1.DP = this.currency.decimals;
        return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
      };
      _createClass(CurrencyAmount2, [{
        key: "wrapped",
        get: function get() {
          if (this.currency.isToken)
            return this;
          return CurrencyAmount2.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
        }
      }]);
      return CurrencyAmount2;
    }(Fraction);
    ONE_HUNDRED = new Fraction(jsbi_default.BigInt(100));
    Percent = function(_Fraction) {
      _inheritsLoose(Percent2, _Fraction);
      function Percent2() {
        var _this;
        _this = _Fraction.apply(this, arguments) || this;
        _this.isPercent = true;
        return _this;
      }
      var _proto = Percent2.prototype;
      _proto.add = function add2(other) {
        return toPercent(_Fraction.prototype.add.call(this, other));
      };
      _proto.subtract = function subtract2(other) {
        return toPercent(_Fraction.prototype.subtract.call(this, other));
      };
      _proto.multiply = function multiply(other) {
        return toPercent(_Fraction.prototype.multiply.call(this, other));
      };
      _proto.divide = function divide2(other) {
        return toPercent(_Fraction.prototype.divide.call(this, other));
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 5;
        }
        return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = 2;
        }
        return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
      };
      return Percent2;
    }(Fraction);
    Price = function(_Fraction) {
      _inheritsLoose(Price2, _Fraction);
      function Price2() {
        var _this;
        var baseCurrency, quoteCurrency, denominator, numerator;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length === 4) {
          baseCurrency = args[0];
          quoteCurrency = args[1];
          denominator = args[2];
          numerator = args[3];
        } else {
          var result = args[0].quoteAmount.divide(args[0].baseAmount);
          var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
          baseCurrency = _ref[0];
          quoteCurrency = _ref[1];
          denominator = _ref[2];
          numerator = _ref[3];
        }
        _this = _Fraction.call(this, numerator, denominator) || this;
        _this.baseCurrency = baseCurrency;
        _this.quoteCurrency = quoteCurrency;
        _this.scalar = new Fraction(jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(baseCurrency.decimals)), jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(quoteCurrency.decimals)));
        return _this;
      }
      var _proto = Price2.prototype;
      _proto.invert = function invert() {
        return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
      };
      _proto.multiply = function multiply(other) {
        !this.quoteCurrency.equals(other.baseCurrency) ? true ? invariant(false, "TOKEN") : invariant(false) : void 0;
        var fraction = _Fraction.prototype.multiply.call(this, other);
        return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
      };
      _proto.quote = function quote(currencyAmount) {
        !currencyAmount.currency.equals(this.baseCurrency) ? true ? invariant(false, "TOKEN") : invariant(false) : void 0;
        var result = _Fraction.prototype.multiply.call(this, currencyAmount);
        return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 6;
        }
        return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = 4;
        }
        return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
      };
      _createClass(Price2, [{
        key: "adjustedForDecimals",
        get: function get() {
          return _Fraction.prototype.multiply.call(this, this.scalar);
        }
      }]);
      return Price2;
    }(Fraction);
    BaseCurrency = /**
     * Constructs an instance of the base class `BaseCurrency`.
     * @param chainId the chain ID on which this currency resides
     * @param decimals decimals of the currency
     * @param symbol symbol of the currency
     * @param name of the currency
     */
    function BaseCurrency2(chainId, decimals, symbol, name) {
      !Number.isSafeInteger(chainId) ? true ? invariant(false, "CHAIN_ID") : invariant(false) : void 0;
      !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? true ? invariant(false, "DECIMALS") : invariant(false) : void 0;
      this.chainId = chainId;
      this.decimals = decimals;
      this.symbol = symbol;
      this.name = name;
    };
    NativeCurrency = function(_BaseCurrency) {
      _inheritsLoose(NativeCurrency2, _BaseCurrency);
      function NativeCurrency2() {
        var _this;
        _this = _BaseCurrency.apply(this, arguments) || this;
        _this.isNative = true;
        _this.isToken = false;
        return _this;
      }
      return NativeCurrency2;
    }(BaseCurrency);
    startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;
    Token = function(_BaseCurrency) {
      _inheritsLoose(Token2, _BaseCurrency);
      function Token2(chainId, address, decimals, symbol, name, bypassChecksum, buyFeeBps, sellFeeBps) {
        var _this;
        _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;
        _this.isNative = false;
        _this.isToken = true;
        if (bypassChecksum) {
          _this.address = checkValidAddress(address);
        } else {
          _this.address = validateAndParseAddress(address);
        }
        if (buyFeeBps) {
          !buyFeeBps.gte(BigNumber.from(0)) ? true ? invariant(false, "NON-NEGATIVE FOT FEES") : invariant(false) : void 0;
        }
        if (sellFeeBps) {
          !sellFeeBps.gte(BigNumber.from(0)) ? true ? invariant(false, "NON-NEGATIVE FOT FEES") : invariant(false) : void 0;
        }
        _this.buyFeeBps = buyFeeBps;
        _this.sellFeeBps = sellFeeBps;
        return _this;
      }
      var _proto = Token2.prototype;
      _proto.equals = function equals(other) {
        return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
      };
      _proto.sortsBefore = function sortsBefore(other) {
        !(this.chainId === other.chainId) ? true ? invariant(false, "CHAIN_IDS") : invariant(false) : void 0;
        !(this.address.toLowerCase() !== other.address.toLowerCase()) ? true ? invariant(false, "ADDRESSES") : invariant(false) : void 0;
        return this.address.toLowerCase() < other.address.toLowerCase();
      };
      _createClass(Token2, [{
        key: "wrapped",
        get: function get() {
          return this;
        }
      }]);
      return Token2;
    }(BaseCurrency);
    WETH9 = (_WETH = {}, _WETH[1] = new Token(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH[3] = new Token(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[4] = new Token(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[5] = new Token(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH[42] = new Token(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH[10] = new Token(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[69] = new Token(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[11155420] = new Token(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[42161] = new Token(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"), _WETH[421611] = new Token(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"), _WETH[421614] = new Token(421614, "0x980B62Da83eFf3D4576C647993b0c1D7faf17c73", 18, "WETH", "Wrapped Ether"), _WETH[8453] = new Token(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"), _WETH[56] = new Token(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"), _WETH[137] = new Token(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"), _WETH[43114] = new Token(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"), _WETH);
    Ether = function(_NativeCurrency) {
      _inheritsLoose(Ether2, _NativeCurrency);
      function Ether2(chainId) {
        return _NativeCurrency.call(this, chainId, 18, "ETH", "Ether") || this;
      }
      Ether2.onChain = function onChain(chainId) {
        var _this$_etherCache$cha;
        return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether2(chainId);
      };
      var _proto = Ether2.prototype;
      _proto.equals = function equals(other) {
        return other.isNative && other.chainId === this.chainId;
      };
      _createClass(Ether2, [{
        key: "wrapped",
        get: function get() {
          var weth9 = WETH9[this.chainId];
          !!!weth9 ? true ? invariant(false, "WRAPPED") : invariant(false) : void 0;
          return weth9;
        }
      }]);
      return Ether2;
    }(NativeCurrency);
    Ether._etherCache = {};
    MAX_SAFE_INTEGER2 = jsbi_default.BigInt(Number.MAX_SAFE_INTEGER);
    ZERO = jsbi_default.BigInt(0);
    ONE2 = jsbi_default.BigInt(1);
    TWO = jsbi_default.BigInt(2);
  }
});

export {
  invariant,
  init_tiny_invariant,
  ChainId,
  SUPPORTED_CHAINS,
  NativeCurrencyName,
  UNI_ADDRESSES,
  UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS,
  V2_FACTORY_ADDRESS,
  V2_FACTORY_ADDRESSES,
  V2_ROUTER_ADDRESS,
  V2_ROUTER_ADDRESSES,
  CHAIN_TO_ADDRESSES_MAP,
  V3_CORE_FACTORY_ADDRESSES,
  V3_MIGRATOR_ADDRESSES,
  MULTICALL_ADDRESSES,
  GOVERNANCE_ALPHA_V0_ADDRESSES,
  GOVERNANCE_ALPHA_V1_ADDRESSES,
  GOVERNANCE_BRAVO_ADDRESSES,
  TIMELOCK_ADDRESSES,
  MERKLE_DISTRIBUTOR_ADDRESS,
  ARGENT_WALLET_DETECTOR_ADDRESS,
  QUOTER_ADDRESSES,
  NONFUNGIBLE_POSITION_MANAGER_ADDRESSES,
  ENS_REGISTRAR_ADDRESSES,
  SOCKS_CONTROLLER_ADDRESSES,
  TICK_LENS_ADDRESSES,
  MIXED_ROUTE_QUOTER_V1_ADDRESSES,
  SWAP_ROUTER_02_ADDRESSES,
  TradeType,
  Rounding,
  MaxUint256,
  Fraction,
  CurrencyAmount,
  Percent,
  Price,
  NativeCurrency,
  validateAndParseAddress,
  Token,
  WETH9,
  Ether,
  computePriceImpact,
  sortedInsert,
  sqrt,
  sdk_core_esm_exports,
  init_sdk_core_esm
};
//# sourceMappingURL=chunk-WW45MY27.js.map
